C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE SEEKFREE_VL53L0X
OBJECT MODULE PLACED IN .\Out_File\SEEKFREE_VL53L0X.obj
COMPILER INVOKED BY: D:\Keil5\C251\BIN\C251.EXE ..\..\Libraries\seekfree_peripheral\SEEKFREE_VL53L0X.c XSMALL INTR2 WARN
                    -INGLEVEL(3) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripher
                    -al;..\CODE;..\USER\inc;..\USER\src) DEBUG PRINT(.\Out_File\SEEKFREE_VL53L0X.lst) TABS(2) OBJECT(.\Out_File\SEEKFREE_VL53
                    -L0X.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * MM32F527X-E9P Opensourec Library å³ï¼ˆMM32F527X-E9P å¼€æºåº“ï¼‰æ˜¯ä¸€ä¸ªåŸºäºå®˜æ–¹ SDK æ¥å£çš„ç¬¬
             -ä¸‰æ–¹å¼€æºåº“
    3          * Copyright (c) 2022 SEEKFREE é€é£ç§‘æŠ€
    4          * 
    5          * æœ¬æ–‡ä»¶æ˜¯ MM32F527X-E9P å¼€æºåº“çš„ä¸€éƒ¨åˆ†
    6          * 
    7          * MM32F527X-E9P å¼€æºåº“ æ˜¯å…è´¹è½¯ä»¶
    8          * æ‚¨å¯ä»¥æ ¹æ®è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒçš„ GPLï¼ˆGNU General Public Licenseï¼Œå³ GNUé€šç”¨å…¬å…±è®¸
             -å¯è¯ï¼‰çš„æ¡æ¬¾
    9          * å³ GPL çš„ç¬¬3ç‰ˆï¼ˆå³ GPL3.0ï¼‰æˆ–ï¼ˆæ‚¨é€‰æ‹©çš„ï¼‰ä»»ä½•åæ¥çš„ç‰ˆæœ¬ï¼Œé‡æ–°å‘å¸ƒå’Œ/æˆ–ä¿®æ”
             -¹å®ƒ
   10          * 
   11          * æœ¬å¼€æºåº“çš„å‘å¸ƒæ˜¯å¸Œæœ›å®ƒèƒ½å‘æŒ¥ä½œç”¨ï¼Œä½†å¹¶æœªå¯¹å…¶ä½œä»»ä½•çš„ä¿è¯
   12          * ç”šè‡³æ²¡æœ‰éšå«çš„é€‚é”€æ€§æˆ–é€‚åˆç‰¹å®šç”¨é€”çš„ä¿è¯
   13          * æ›´å¤šç»†èŠ‚è¯·å‚è§ GPL
   14          * 
   15          * æ‚¨åº”è¯¥åœ¨æ”¶åˆ°æœ¬å¼€æºåº“çš„åŒæ—¶æ”¶åˆ°ä¸€ä»½ GPL çš„å‰¯æœ¬
   16          * å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜…<https://www.gnu.org/licenses/>
   17          * 
   18          * é¢å¤–æ³¨æ˜ï¼š
   19          * æœ¬å¼€æºåº“ä½¿ç”¨ GPL3.0 å¼€æºè®¸å¯è¯åè®® ä»¥ä¸Šè®¸å¯ç”³æ˜ä¸ºè¯‘æ–‡ç‰ˆæœ¬
   20          * è®¸å¯ç”³æ˜è‹±æ–‡ç‰ˆåœ¨ libraries/doc æ–‡ä»¶å¤¹ä¸‹çš„ GPL3_permission_statement.txt æ–‡ä»¶ä¸­
   21          * è®¸å¯è¯å‰¯æœ¬åœ¨ libraries æ–‡ä»¶å¤¹ä¸‹ å³è¯¥æ–‡ä»¶å¤¹ä¸‹çš„ LICENSE æ–‡ä»¶
   22          * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åº ä½†ä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ï¼ˆå³æœ¬
             -å£°æ˜ï¼‰
   23          * 
   24          * æ–‡ä»¶åç§°          zf_device_vl53l0x
   25          * å…¬å¸åç§°          æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   26          * ç‰ˆæœ¬ä¿¡æ¯          æŸ¥çœ‹ libraries/doc æ–‡ä»¶å¤¹å†… version æ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   27          * å¼€å‘ç¯å¢ƒ          MDK 5.37
   28          * é€‚ç”¨å¹³å°          MM32F527X_E9P
   29          * åº—é“ºé“¾æ¥          https://seekfree.taobao.com/
   30          * 
   31          * ä¿®æ”¹è®°å½•
   32          * æ—¥æœŸ              ä½œè€…                å¤‡æ³¨
   33          * 2022-08-10        Teternal            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * æ¥çº¿å®šä¹‰ï¼š
   37          *                   ------------------------------------
   38          *                   æ¨¡å—ç®¡è„š            å•ç‰‡æœºç®¡è„š
   39          *                   SCL                 æŸ¥çœ‹ zf_device_vl53l0x.h ä¸­ VL53L0X_SCL_PIN  å®å®šä¹‰
   40          *                   SDA                 æŸ¥çœ‹ zf_device_vl53l0x.h ä¸­ VL53L0X_SDA_PIN  å®å®šä¹‰
   41          *                   VCC                 5V ç”µæº
   42          *                   GND                 ç”µæºåœ°
   43          *                   ------------------------------------
   44          *********************************************************************************************************
             -***********/
   45          
   46          
   47          #include "zf_delay.h"
   48          #include "SEEKFREE_VL53L0X.h"
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 2   

   49          #include "stdio.h"
   50          #include "string.h"
   51          
   52          
   53          #pragma warning disable = 183
   54          
   55          
   56          uint8 vl53l0x_finsh_flag;
   57          uint16 vl53l0x_distance_mm;
   58          
   59          
   60          
   61          #define GET_VL53L0X_SDA         VL53L0X_SDA_PIN
   62          #define VL53L0X_SDA_LOW()           VL53L0X_SDA_PIN = 0   //IOå£è¾“å‡ºä½ç”µå¹³
   63          #define VL53L0X_SDA_HIGH()          VL53L0X_SDA_PIN = 1   //IOå£è¾“å‡ºé«˜ç”µå¹³
   64          
   65          #define VL53L0X_SCL_LOW()           VL53L0X_SCL_PIN = 0   //IOå£è¾“å‡ºä½ç”µå¹³
   66          #define VL53L0X_SCL_HIGH()          VL53L0X_SCL_PIN = 1   //IOå£è¾“å‡ºé«˜ç”µå¹³
   67          
   68          #define ack 1      //ä¸»åº”ç­”
   69          #define no_ack 0   //ä»åº”ç­”  
   70          
   71          //-------------------------------------------------------------------------------------------------------
             -------------
   72          //  @brief      æ¨¡æ‹ŸIICå»¶æ—¶
   73          //  @return     void            
   74          //  @since      v1.0
   75          //  Sample usage:       å¦‚æœIICé€šè®¯å¤±è´¥å¯ä»¥å°è¯•å¢åŠ jçš„å€¼
   76          //-------------------------------------------------------------------------------------------------------
             -------------
   77          static void vl53l0x_simiic_delay(void)
   78          {
   79   1          uint16 j=VL53L0X_SOFT_IIC_DELAY;   
   80   1        while(j--);
   81   1      }
   82          
   83          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
   84          static void vl53l0x_simiic_start(void)
   85          {
   86   1        VL53L0X_SDA_HIGH();
   87   1        VL53L0X_SCL_HIGH();
   88   1        vl53l0x_simiic_delay();
   89   1        VL53L0X_SDA_LOW();
   90   1        vl53l0x_simiic_delay();
   91   1        VL53L0X_SCL_LOW();
   92   1      }
   93          
   94          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
   95          static void vl53l0x_simiic_stop(void)
   96          {
   97   1        VL53L0X_SDA_LOW();
   98   1        VL53L0X_SCL_LOW();
   99   1        vl53l0x_simiic_delay();
  100   1        VL53L0X_SCL_HIGH();
  101   1        vl53l0x_simiic_delay();
  102   1        VL53L0X_SDA_HIGH();
  103   1        vl53l0x_simiic_delay();
  104   1      }
  105          
  106          //ä¸»åº”ç­”(åŒ…å«ack:SDA=0å’Œno_ack:SDA=0)
  107          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  108          static void vl53l0x_simiic_sendack(unsigned char ack_dat)
  109          {
  110   1          VL53L0X_SCL_LOW();
  111   1        vl53l0x_simiic_delay();
  112   1        if(ack_dat) VL53L0X_SDA_LOW();
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 3   

  113   1          else      VL53L0X_SDA_HIGH();
  114   1      
  115   1          VL53L0X_SCL_HIGH();
  116   1          vl53l0x_simiic_delay();
  117   1          VL53L0X_SCL_LOW();
  118   1          vl53l0x_simiic_delay();
  119   1      }
  120          
  121          
  122          static int vl53l0x_sccb_waitack(void)
  123          {
  124   1          VL53L0X_SCL_LOW();
  125   1      
  126   1        vl53l0x_simiic_delay();
  127   1        
  128   1        VL53L0X_SCL_HIGH();
  129   1          vl53l0x_simiic_delay();
  130   1        
  131   1          if(GET_VL53L0X_SDA)           //åº”ç­”ä¸ºé«˜ç”µå¹³ï¼Œå¼‚å¸¸ï¼Œé€šä¿¡å¤±è´¥
  132   1          {
  133   2      
  134   2              VL53L0X_SCL_LOW();
  135   2              return 0;
  136   2          }
  137   1      
  138   1          VL53L0X_SCL_LOW();
  139   1        vl53l0x_simiic_delay();
  140   1          return 1;
  141   1      }
  142          
  143          //å­—èŠ‚å‘é€ç¨‹åº
  144          //å‘é€c(å¯ä»¥æ˜¯æ•°æ®ä¹Ÿå¯æ˜¯åœ°å€)ï¼Œé€å®Œåæ¥æ”¶ä»åº”ç­”
  145          //ä¸è€ƒè™‘ä»åº”ç­”ä½
  146          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  147          static void vl53l0x_send_ch(uint8 c)
  148          {
  149   1        uint8 i = 8;
  150   1          while(i--)
  151   1          {
  152   2              if(c & 0x80)  VL53L0X_SDA_HIGH();//SDA è¾“å‡ºæ•°æ®
  153   2              else      VL53L0X_SDA_LOW();
  154   2              c <<= 1;
  155   2              vl53l0x_simiic_delay();
  156   2              VL53L0X_SCL_HIGH();                //SCL æ‹‰é«˜ï¼Œé‡‡é›†ä¿¡å·
  157   2              vl53l0x_simiic_delay();
  158   2              VL53L0X_SCL_LOW();                //SCL æ—¶é’Ÿçº¿æ‹‰ä½
  159   2          }
  160   1        vl53l0x_sccb_waitack();
  161   1      }
  162          
  163          
  164          //å­—èŠ‚æ¥æ”¶ç¨‹åº
  165          //æ¥æ”¶å™¨ä»¶ä¼ æ¥çš„æ•°æ®ï¼Œæ­¤ç¨‹åºåº”é…åˆ|ä¸»åº”ç­”å‡½æ•°|ä½¿ç”¨
  166          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  167          static uint8 vl53l0x_read_ch(uint8 ack_x)
  168          {
  169   1          uint8 i;
  170   1          uint8 c;
  171   1          c=0;
  172   1          VL53L0X_SCL_LOW();
  173   1          vl53l0x_simiic_delay();
  174   1          VL53L0X_SDA_HIGH();             
  175   1      
  176   1          for(i=0;i<8;i++)
  177   1          {
  178   2              vl53l0x_simiic_delay();
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 4   

  179   2              VL53L0X_SCL_LOW();         //ç½®æ—¶é’Ÿçº¿ä¸ºä½ï¼Œå‡†å¤‡æ¥æ”¶æ•°æ®ä½
  180   2              vl53l0x_simiic_delay();
  181   2              VL53L0X_SCL_HIGH();         //ç½®æ—¶é’Ÿçº¿ä¸ºé«˜ï¼Œä½¿æ•°æ®çº¿ä¸Šæ•°æ®æœ‰æ•ˆ
  182   2              vl53l0x_simiic_delay();
  183   2              c<<=1;
  184   2              if(GET_VL53L0X_SDA) 
  185   2              {
  186   3                  c+=1;   //è¯»æ•°æ®ä½ï¼Œå°†æ¥æ”¶çš„æ•°æ®å­˜c
  187   3              }
  188   2          }
  189   1      
  190   1        VL53L0X_SCL_LOW();
  191   1        vl53l0x_simiic_delay();
  192   1        vl53l0x_simiic_sendack(ack_x);
  193   1        
  194   1          return c;
  195   1      }
  196          
  197          
  198          //-------------------------------------------------------------------------------------------------------
             -------------
  199          //  @brief      æ¨¡æ‹ŸIICå†™æ•°æ®åˆ°è®¾å¤‡å¯„å­˜å™¨å‡½æ•°
  200          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  201          //  @param      reg       å¯„å­˜å™¨åœ°å€
  202          //  @param      dat       å†™å…¥çš„æ•°æ®
  203          //  @return     void            
  204          //  @since      v1.0
  205          //  Sample usage:       
  206          //-------------------------------------------------------------------------------------------------------
             -------------
  207          static void vl53l0x_simiic_write_dats(uint8 dev_add, uint8 *dat, uint32 len)
  208          {
  209   1        vl53l0x_simiic_start();
  210   1          vl53l0x_send_ch( (dev_add<<1) | 0x00);   //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  211   1        while(len--)
  212   1        {
  213   2          vl53l0x_send_ch( *dat++ );           //å‘é€éœ€è¦å†™å…¥çš„æ•°æ®
  214   2        }
  215   1      
  216   1        
  217   1        vl53l0x_simiic_stop();
  218   1      }
  219          
  220          
  221          //-------------------------------------------------------------------------------------------------------
             -------------
  222          //  @brief      æ¨¡æ‹ŸIICå†™æ•°æ®åˆ°è®¾å¤‡å¯„å­˜å™¨å‡½æ•°
  223          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  224          //  @param      reg       å¯„å­˜å™¨åœ°å€
  225          //  @param      dat       å†™å…¥çš„æ•°æ®
  226          //  @return     void            
  227          //  @since      v1.0
  228          //  Sample usage:       
  229          //-------------------------------------------------------------------------------------------------------
             -------------
  230          static void vl53l0x_simiic_write_reg(uint8 dev_add, uint8 reg, uint8 dat)
  231          {
  232   1        vl53l0x_simiic_start();
  233   1          vl53l0x_send_ch( (dev_add<<1) | 0x00);   //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  234   1        vl53l0x_send_ch( reg );            //å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
  235   1        vl53l0x_send_ch( dat );            //å‘é€éœ€è¦å†™å…¥çš„æ•°æ®
  236   1        vl53l0x_simiic_stop();
  237   1      }
  238          
  239          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 5   

  240          //  @brief      æ¨¡æ‹ŸIICä»è®¾å¤‡å¯„å­˜å™¨è¯»å–æ•°æ®
  241          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  242          //  @param      reg       å¯„å­˜å™¨åœ°å€
  243          //  @param      type      é€‰æ‹©é€šä¿¡æ–¹å¼æ˜¯IIC  è¿˜æ˜¯ SCCB
  244          //  @return     uint8     è¿”å›å¯„å­˜å™¨çš„æ•°æ®      
  245          //  @since      v1.0
  246          //  Sample usage:       
  247          //-------------------------------------------------------------------------------------------------------
             -------------
  248          static uint8 vl53l0x_simiic_read_reg(uint8 dev_add, uint8 reg)
  249          {
  250   1        uint8 dat;
  251   1        vl53l0x_simiic_start();
  252   1          vl53l0x_send_ch( (dev_add<<1) | 0x00);  //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  253   1        vl53l0x_send_ch( reg );           //å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
  254   1      
  255   1        
  256   1        vl53l0x_simiic_start();
  257   1        vl53l0x_send_ch( (dev_add<<1) | 0x01);  //å‘é€å™¨ä»¶åœ°å€åŠ è¯»ä½
  258   1        dat = vl53l0x_read_ch(no_ack);          //è¯»å–æ•°æ®
  259   1        vl53l0x_simiic_stop();
  260   1        
  261   1        return dat;
  262   1      }
  263          
  264          //-------------------------------------------------------------------------------------------------------
             -------------
  265          //  @brief      æ¨¡æ‹ŸIICè¯»å–å¤šå­—èŠ‚æ•°æ®
  266          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  267          //  @param      reg       å¯„å­˜å™¨åœ°å€
  268          //  @param      dat_add     æ•°æ®ä¿å­˜çš„åœ°å€æŒ‡é’ˆ
  269          //  @param      num       è¯»å–å­—èŠ‚æ•°é‡
  270          //  @param      type      é€‰æ‹©é€šä¿¡æ–¹å¼æ˜¯IIC  è¿˜æ˜¯ SCCB
  271          //  @return     uint8     è¿”å›å¯„å­˜å™¨çš„æ•°æ®      
  272          //  @since      v1.0
  273          //  Sample usage:       
  274          //-------------------------------------------------------------------------------------------------------
             -------------
  275          static void vl53l0x_simiic_read_regs(uint8 dev_add, uint8 reg, uint8 *dat_add, uint32 num)
  276          {
  277   1        vl53l0x_simiic_start();
  278   1          vl53l0x_send_ch( (dev_add<<1) | 0x00);  //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  279   1        vl53l0x_send_ch( reg );           //å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
  280   1      
  281   1        
  282   1        vl53l0x_simiic_start();
  283   1        vl53l0x_send_ch( (dev_add<<1) | 0x01);  //å‘é€å™¨ä»¶åœ°å€åŠ è¯»ä½
  284   1          while(--num)
  285   1          {
  286   2              *dat_add = vl53l0x_read_ch(ack); //è¯»å–æ•°æ®
  287   2              dat_add++;
  288   2          }
  289   1          *dat_add = vl53l0x_read_ch(no_ack); //è¯»å–æ•°æ®
  290   1        vl53l0x_simiic_stop();
  291   1      }
  292          
  293          //-------------------------------------------------------------------------------------------------------
             -------------
  294          //  @brief      æ¨¡æ‹ŸIICè¯»å–å¤šå­—èŠ‚æ•°æ®
  295          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  296          //  @param      reg       å¯„å­˜å™¨åœ°å€
  297          //  @param      dat_add     æ•°æ®ä¿å­˜çš„åœ°å€æŒ‡é’ˆ
  298          //  @param      num       è¯»å–å­—èŠ‚æ•°é‡
  299          //  @param      type      é€‰æ‹©é€šä¿¡æ–¹å¼æ˜¯IIC  è¿˜æ˜¯ SCCB
  300          //  @return     uint8     è¿”å›å¯„å­˜å™¨çš„æ•°æ®      
  301          //  @since      v1.0
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 6   

  302          //  Sample usage:       
  303          //-------------------------------------------------------------------------------------------------------
             -------------
  304          static void vl53l0x_simiic_read_regs_1(uint8 dev_add, uint8 reg, uint8 *dat_add, uint32 num)
  305          {
  306   1        vl53l0x_simiic_start();
  307   1          vl53l0x_send_ch( (dev_add<<1) | 0x00);  //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  308   1        vl53l0x_send_ch( reg );           //å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
  309   1      
  310   1        
  311   1        vl53l0x_simiic_start();
  312   1        vl53l0x_send_ch( (dev_add<<1) | 0x01);  //å‘é€å™¨ä»¶åœ°å€åŠ è¯»ä½
  313   1          while(--num)
  314   1          {
  315   2              *dat_add = vl53l0x_read_ch(ack); //è¯»å–æ•°æ®
  316   2              dat_add++;
  317   2          }
  318   1          *dat_add = vl53l0x_read_ch(no_ack); //è¯»å–æ•°æ®
  319   1        vl53l0x_simiic_stop();
  320   1      }
  321          
  322          
  323          #define vl53l0x_write_array(dat, len)          (vl53l0x_simiic_write_dats(VL53L0X_DEV_ADDR, (dat), (len))
             -)
  324          #define vl53l0x_write_register(reg, dat)       (vl53l0x_simiic_write_reg(VL53L0X_DEV_ADDR, (reg), (dat)))
  325          #define vl53l0x_read_register(reg)             (vl53l0x_simiic_read_reg (VL53L0X_DEV_ADDR, (reg)))
  326          #define vl53l0x_read_registers(reg, dat, len)  (vl53l0x_simiic_read_regs(VL53L0X_DEV_ADDR, (reg), (dat), 
             -(len)))
  327          #define vl53l0x_read_registers_1(reg, dat, len)  (vl53l0x_simiic_read_regs_1(VL53L0X_DEV_ADDR, (reg), (da
             -t), (len)))
  328          
  329          // è¿™ä¸ªé€Ÿç‡è¡¨ç¤ºä»ç›®æ ‡åå°„å¹¶è¢«è®¾å¤‡æ£€æµ‹åˆ°çš„ä¿¡å·çš„æŒ¯å¹…
  330          // è®¾ç½®æ­¤é™åˆ¶å¯ä»¥ç¡®å®šä¼ æ„Ÿå™¨æŠ¥å‘Šæœ‰æ•ˆè¯»æ•°æ‰€éœ€çš„æœ€å°æµ‹é‡å€¼
  331          // è®¾ç½®ä¸€ä¸ªè¾ƒä½çš„é™åˆ¶å¯ä»¥å¢åŠ ä¼ æ„Ÿå™¨çš„æµ‹é‡èŒƒå›´
  332          // ä½†ä¼¼ä¹ä¹Ÿå¢åŠ äº† <ç”±äºæ¥è‡ªç›®æ ‡ä»¥å¤–çš„ç‰©ä½“çš„ä¸éœ€è¦çš„åå°„å¯¼è‡´> å¾—åˆ°ä¸å‡†ç¡®è¯
             -»æ•°çš„å¯èƒ½æ€§
  333          // é»˜è®¤ä¸º 0.25 MCPS å¯é¢„è®¾èŒƒå›´ä¸º 0 - 511.99
  334          #define VL53L0X_DEFAULT_RATE_LIMIT  (0.25)
  335          
  336          // ä»å¯„å­˜å™¨æ•°æ®è§£ç  PCLKs ä¸­ VCSEL (vertical cavity surface emitting laser) çš„è„‰å®½å‘¨æœŸ
  337          #define decode_vcsel_period(reg_val)            (((reg_val) + 1) << 1)
  338          
  339          // ä» PCLK ä¸­çš„ VCSEL å‘¨æœŸè®¡ç®—å®å‘¨æœŸ (ä»¥ *çº³ç§’ä¸ºå•ä½)
  340          // PLL_period_ps = 1655
  341          // macro_period_vclks = 2304
  342          #define calc_macro_period(vcsel_period_pclks)   ((((uint32)2304 * (vcsel_period_pclks) * 1655) + 500) / 1
             -000)
  343          
  344          //-------------------------------------------------------------------------------------------------------
             -------------
  345          // å‡½æ•°ç®€ä»‹     è·å–è®¾å¤‡ SPAD ä¿¡æ¯
  346          // å‚æ•°è¯´æ˜     index           ç´¢å¼•
  347          // å‚æ•°è¯´æ˜     type            ç±»å‹å€¼
  348          // è¿”å›å‚æ•°     uint8           æ˜¯å¦æˆåŠŸ 0-æˆåŠŸ 1-å¤±è´¥
  349          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_get_spad_info(index, type_is_aperture);
  350          // å¤‡æ³¨ä¿¡æ¯     
  351          //-------------------------------------------------------------------------------------------------------
             -------------
  352          static uint8 vl53l0x_get_spad_info (uint8 *index, uint8 *type_is_aperture)
  353          {
  354   1          uint8 tmp = 0;
  355   1          uint8 return_state = 0;
  356   1          volatile uint16 loop_count = 0;
  357   1      
  358   1          do
  359   1          {
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 7   

  360   2              vl53l0x_write_register(0x80, 0x01);
  361   2              vl53l0x_write_register(0xFF, 0x01);
  362   2              vl53l0x_write_register(0x00, 0x00);
  363   2      
  364   2              vl53l0x_write_register(0xFF, 0x06);
  365   2              vl53l0x_read_registers(0x83, &tmp, 1);
  366   2              vl53l0x_write_register(0x83, tmp | 0x04);
  367   2              vl53l0x_write_register(0xFF, 0x07);
  368   2              vl53l0x_write_register(0x81, 0x01);
  369   2      
  370   2              vl53l0x_write_register(0x80, 0x01);
  371   2      
  372   2              vl53l0x_write_register(0x94, 0x6b);
  373   2              vl53l0x_write_register(0x83, 0x00);
  374   2      
  375   2              tmp = 0x00;
  376   2              while(tmp != 0x10)
  377   2              {
  378   3                  vl53l0x_read_registers(0x83, &tmp, 1);
  379   3                  loop_count++;
  380   3                  if(loop_count == VL53L0X_TIMEOUT_COUNT)
  381   3                  {
  382   4                      return_state = 1;
  383   4                      break;
  384   4                  }
  385   3              }
  386   2          
  387   2              if(return_state)
  388   2              {
  389   3                  break;
  390   3              }
  391   2              vl53l0x_write_register(0x83, 0x01);
  392   2              vl53l0x_read_registers(0x92, &tmp, 1);
  393   2      
  394   2              *index = tmp & 0x7f;
  395   2              *type_is_aperture = (tmp >> 7) & 0x01;
  396   2      
  397   2              vl53l0x_write_register(0x81, 0x00);
  398   2              vl53l0x_write_register(0xFF, 0x06);
  399   2              vl53l0x_read_registers(0x83, &tmp, 1);
  400   2              vl53l0x_write_register(0x83, tmp);
  401   2              vl53l0x_write_register(0xFF, 0x01);
  402   2              vl53l0x_write_register(0x00, 0x01);
  403   2      
  404   2              vl53l0x_write_register(0xFF, 0x00);
  405   2              vl53l0x_write_register(0x80, 0x00);
  406   2          }while(0);
  407   1      
  408   1          return return_state;
  409   1      }
  410          
  411          //-------------------------------------------------------------------------------------------------------
             -------------
  412          // å‡½æ•°ç®€ä»‹     å°†è¶…æ—¶æ•°å€¼ä» MCLKs è½¬æ¢åˆ°å¯¹åº”çš„ ms
  413          // å‚æ•°è¯´æ˜     timeout_period_mclks    è¶…æ—¶å‘¨æœŸ MCLKs
  414          // å‚æ•°è¯´æ˜     vcsel_period_pclks      PCLK å€¼
  415          // è¿”å›å‚æ•°     uint32                  è¿”å›è¶…æ—¶æ•°å€¼
  416          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_timeout_mclks_to_microseconds(timeout_period_mclks, vcsel_period_pclks);
  417          // å¤‡æ³¨ä¿¡æ¯     å°†åºåˆ—æ­¥éª¤è¶…æ—¶ä»å…·æœ‰ç»™å®š VCSEL å‘¨æœŸçš„ MCLK (ä»¥ PCLK ä¸ºå•ä½)è½¬æ¢ä
             -¸ºå¾®ç§’
  418          //-------------------------------------------------------------------------------------------------------
             -------------
  419          static uint32 vl53l0x_timeout_mclks_to_microseconds (uint16 timeout_period_mclks, uint8 vcsel_period_pclk
             -s)
  420          {
  421   1          uint32 macro_period_ns = calc_macro_period(vcsel_period_pclks);
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 8   

  422   1      
  423   1          return ((timeout_period_mclks * macro_period_ns) + (macro_period_ns / 2)) / 1000;
  424   1      }
  425          
  426          //-------------------------------------------------------------------------------------------------------
             -------------
  427          // å‡½æ•°ç®€ä»‹     å°†è¶…æ—¶æ•°å€¼ä» ms è½¬æ¢åˆ°å¯¹åº”çš„ MCLKs
  428          // å‚æ•°è¯´æ˜     timeout_period_us   è¶…æ—¶å‘¨æœŸ å¾®ç§’å•ä½
  429          // å‚æ•°è¯´æ˜     vcsel_period_pclks  PCLK å€¼
  430          // è¿”å›å‚æ•°     uint32              è¿”å›è¶…æ—¶æ•°å€¼
  431          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_timeout_microseconds_to_mclks(timeout_period_us, vcsel_period_pclks);
  432          // å¤‡æ³¨ä¿¡æ¯     å°†åºåˆ—æ­¥éª¤è¶…æ—¶ä»å¾®ç§’è½¬æ¢ä¸ºå…·æœ‰ç»™å®š VCSEL å‘¨æœŸçš„ MCLK (ä»¥ PCLK ä¸
             -ºå•ä½)
  433          //-------------------------------------------------------------------------------------------------------
             -------------
  434          static uint32 vl53l0x_timeout_microseconds_to_mclks (uint32 timeout_period_us, uint8 vcsel_period_pclks)
  435          {
  436   1          uint32 macro_period_ns = calc_macro_period(vcsel_period_pclks);
  437   1      
  438   1          return (((timeout_period_us * 1000) + (macro_period_ns / 2)) / macro_period_ns);
  439   1      }
  440          
  441          //-------------------------------------------------------------------------------------------------------
             -------------
  442          // å‡½æ•°ç®€ä»‹     å¯¹è¶…æ—¶æ•°å€¼è¿›è¡Œè§£ç 
  443          // å‚æ•°è¯´æ˜     reg_val         è¶…æ—¶æ—¶é•¿ å¯„å­˜å™¨å€¼
  444          // è¿”å›å‚æ•°     uint16          è¿”å›è¶…æ—¶æ•°å€¼
  445          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_decode_timeout(reg_val);
  446          // å¤‡æ³¨ä¿¡æ¯     ä»å¯„å­˜å™¨å€¼è§£ç  MCLK ä¸­çš„åºåˆ—æ­¥éª¤è¶…æ—¶   
  447          //-------------------------------------------------------------------------------------------------------
             -------------
  448          static uint16 vl53l0x_decode_timeout (uint16 reg_val)
  449          {
  450   1        // æ ¼å¼: (LSByte * 2 ^ MSByte) + 1
  451   1          return  (uint16)((reg_val & 0x00FF) <<
  452   1                  (uint16)((reg_val & 0xFF00) >> 8)) + 1;
  453   1      }
  454          
  455          //-------------------------------------------------------------------------------------------------------
             -------------
  456          // å‡½æ•°ç®€ä»‹     å¯¹è¶…æ—¶æ•°å€¼è¿›è¡Œç¼–ç 
  457          // å‚æ•°è¯´æ˜     timeout_mclks   è¶…æ—¶æ—¶é•¿ -MCLKs å€¼
  458          // è¿”å›å‚æ•°     uint16          è¿”å›ç¼–ç å€¼
  459          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_encode_timeout(timeout_mclks);
  460          // å¤‡æ³¨ä¿¡æ¯     åœ¨ MCLK ä¸­å¯¹è¶…æ—¶çš„åºåˆ—æ­¥éª¤è¶…æ—¶å¯„å­˜å™¨å€¼è¿›è¡Œç¼–ç 
  461          //-------------------------------------------------------------------------------------------------------
             -------------
  462          static uint16 vl53l0x_encode_timeout (uint16 timeout_mclks)
  463          {
  464   1          uint32 ls_byte = 0;
  465   1          uint16 ms_byte = 0;
  466   1          uint16 return_data = 0;
  467   1      
  468   1          if (timeout_mclks > 0)
  469   1          {
  470   2              // æ ¼å¼: (LSByte * 2 ^ MSByte) + 1
  471   2              ls_byte = timeout_mclks - 1;
  472   2              while ((ls_byte & 0xFFFFFF00) > 0)
  473   2              {
  474   3                  ls_byte >>= 1;
  475   3                  ms_byte++;
  476   3              }
  477   2              return_data = (ms_byte << 8) | (ls_byte & 0xFF);
  478   2          }
  479   1          return return_data;
  480   1      }
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 9   

  481          
  482          //-------------------------------------------------------------------------------------------------------
             -------------
  483          // å‡½æ•°ç®€ä»‹     è·å–åºåˆ—æ­¥éª¤ä½¿èƒ½è®¾ç½®
  484          // å‚æ•°è¯´æ˜     enables         åºåˆ—ä½¿èƒ½æ­¥éª¤ç»“æ„ä½“
  485          // è¿”å›å‚æ•°     void
  486          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_get_sequence_step_enables(enables);
  487          // å¤‡æ³¨ä¿¡æ¯     
  488          //-------------------------------------------------------------------------------------------------------
             -------------
  489          static void vl53l0x_get_sequence_step_enables(vl53l0x_sequence_enables_step_struct *enables)
  490          {
  491   1          uint8 sequence_config = 0;
  492   1          vl53l0x_read_registers(VL53L0X_SYSTEM_SEQUENCE_CONFIG, &sequence_config, 1);
  493   1      
  494   1          enables->tcc          = (sequence_config >> 4) & 0x1;
  495   1          enables->dss          = (sequence_config >> 3) & 0x1;
  496   1          enables->msrc         = (sequence_config >> 2) & 0x1;
  497   1          enables->pre_range    = (sequence_config >> 6) & 0x1;
  498   1          enables->final_range  = (sequence_config >> 7) & 0x1;
  499   1      }
  500          
  501          //-------------------------------------------------------------------------------------------------------
             -------------
  502          // å‡½æ•°ç®€ä»‹     è·å–è„‰å†²å‘¨æœŸ
  503          // å‚æ•°è¯´æ˜     type            é¢„é‡ç¨‹ç±»å‹
  504          // è¿”å›å‚æ•°     uint8           è¿”å›çš„å‘¨æœŸå€¼
  505          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_get_vcsel_pulse_period(VL53L0X_VCSEL_PERIOD_PER_RANGE);
  506          // å¤‡æ³¨ä¿¡æ¯     åœ¨ PCLKs ä¸­è·å–ç»™å®šå‘¨æœŸç±»å‹çš„ VCSEL è„‰å†²å‘¨æœŸ
  507          //-------------------------------------------------------------------------------------------------------
             -------------
  508          static uint8 vl53l0x_get_vcsel_pulse_period (vl53l0x_vcsel_period_type_enum type)
  509          {
  510   1          uint8 data_buffer = 0;
  511   1          if (type == VL53L0X_VCSEL_PERIOD_PER_RANGE)
  512   1          {
  513   2              vl53l0x_read_registers(VL53L0X_PRE_RANGE_CONFIG_VCSEL_PERIOD, &data_buffer, 1);
  514   2              data_buffer = decode_vcsel_period(data_buffer);
  515   2          }
  516   1          else if (type == VL53L0X_VCSEL_PERIOD_FINAL_RANGE)
  517   1          {
  518   2              vl53l0x_read_registers(VL53L0X_FINAL_RANGE_CONFIG_VCSEL_PERIOD, &data_buffer, 1);
  519   2              data_buffer = decode_vcsel_period(data_buffer);
  520   2          }
  521   1          else
  522   1          {
  523   2              data_buffer = 255;
  524   2          }
  525   1          return data_buffer;
  526   1      }
  527          
  528          //-------------------------------------------------------------------------------------------------------
             -------------
  529          // å‡½æ•°ç®€ä»‹     è·å–åºåˆ—æ­¥éª¤è¶…æ—¶è®¾ç½®
  530          // å‚æ•°è¯´æ˜     enables         åºåˆ—ä½¿èƒ½æ­¥éª¤ç»“æ„ä½“
  531          // å‚æ•°è¯´æ˜     timeouts        åºåˆ—è¶…æ—¶æ­¥éª¤ç»“æ„ä½“
  532          // è¿”å›å‚æ•°     void
  533          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_get_sequence_step_timeouts(enables, timeouts);
  534          // å¤‡æ³¨ä¿¡æ¯     è·å–æ‰€æœ‰è¶…æ—¶è€Œä¸ä»…ä»…æ˜¯è¯·æ±‚çš„è¶…æ—¶ å¹¶ä¸”è¿˜å­˜å‚¨ä¸­é—´å€¼
  535          //-------------------------------------------------------------------------------------------------------
             -------------
  536          static void vl53l0x_get_sequence_step_timeouts (vl53l0x_sequence_enables_step_struct const *enables, vl53
             -l0x_sequence_timeout_step_struct *timeouts)
  537          {
  538   1          uint8 reg_buffer[2];
  539   1          uint16 reg16_buffer = 0;
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 10  

  540   1      
  541   1          timeouts->pre_range_vcsel_period_pclks = vl53l0x_get_vcsel_pulse_period(VL53L0X_VCSEL_PERIOD_PER_RANG
             -E);
  542   1      
  543   1          vl53l0x_read_registers(VL53L0X_MSRC_CONFIG_TIMEOUT_MACROP, reg_buffer, 1);
  544   1          timeouts->msrc_dss_tcc_mclks = reg_buffer[0] + 1;
  545   1          timeouts->msrc_dss_tcc_us = vl53l0x_timeout_mclks_to_microseconds(timeouts->msrc_dss_tcc_mclks, (uint
             -8)timeouts->pre_range_vcsel_period_pclks);
  546   1      
  547   1          vl53l0x_read_registers(VL53L0X_PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI, reg_buffer, 2);
  548   1          reg16_buffer = ((uint16) reg_buffer[0] << 8) | reg_buffer[1];
  549   1          timeouts->pre_range_mclks = vl53l0x_decode_timeout(reg16_buffer);
  550   1          timeouts->pre_range_us = vl53l0x_timeout_mclks_to_microseconds(timeouts->pre_range_mclks, (uint8)time
             -outs->pre_range_vcsel_period_pclks);
  551   1      
  552   1          timeouts->final_range_vcsel_period_pclks = vl53l0x_get_vcsel_pulse_period(VL53L0X_VCSEL_PERIOD_FINAL_
             -RANGE);
  553   1      
  554   1          vl53l0x_read_registers(VL53L0X_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI, reg_buffer, 2);
  555   1          reg16_buffer = ((uint16) reg_buffer[0] << 8) | reg_buffer[1];
  556   1          timeouts->final_range_mclks = vl53l0x_decode_timeout(reg16_buffer);
  557   1      
  558   1          if (enables->pre_range)
  559   1          {
  560   2              timeouts->final_range_mclks -= timeouts->pre_range_mclks;
  561   2          }
  562   1      
  563   1          timeouts->final_range_us = vl53l0x_timeout_mclks_to_microseconds(timeouts->final_range_mclks, (uint8)
             -timeouts->final_range_vcsel_period_pclks);
  564   1      }
  565          
  566          //-------------------------------------------------------------------------------------------------------
             -------------
  567          // å‡½æ•°ç®€ä»‹     æ‰§è¡Œå•æ¬¡å‚è€ƒæ ¡å‡†
  568          // å‚æ•°è¯´æ˜     vhv_init_byte   é¢„è®¾æ ¡å‡†å€¼
  569          // è¿”å›å‚æ•°     uint8           æ“ä½œæ˜¯å¦æˆåŠŸ 0-æˆåŠŸ 1-å¤±è´¥
  570          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_get_vcsel_pulse_period(VL53L0X_VCSEL_PERIOD_PER_RANGE);
  571          // å¤‡æ³¨ä¿¡æ¯     åœ¨ PCLKs ä¸­è·å–ç»™å®šå‘¨æœŸç±»å‹çš„ VCSEL è„‰å†²å‘¨æœŸ
  572          //-------------------------------------------------------------------------------------------------------
             -------------
  573          static uint8 vl53l0x_perform_single_ref_calibration (uint8 vhv_init_byte)
  574          {
  575   1          uint8 return_state = 0;
  576   1          uint8 data_buffer = 0;
  577   1          volatile uint16 loop_count = 0;
  578   1          do
  579   1          {
  580   2              vl53l0x_write_register(VL53L0X_SYSRANGE_START, 0x01 | vhv_init_byte);
  581   2              vl53l0x_read_registers(VL53L0X_MSRC_CONFIG_TIMEOUT_MACROP, &data_buffer, 1);
  582   2              while ((data_buffer & 0x07) == 0)
  583   2              {
  584   3                  if (loop_count > 0x8fe0)
  585   3                  {
  586   4                      return_state = 1;
  587   4                      break;
  588   4                  }
  589   3                  if (loop_count++ % 0x10 == 0)
  590   3                  {
  591   4                      vl53l0x_read_registers(VL53L0X_MSRC_CONFIG_TIMEOUT_MACROP, &data_buffer, 1);
  592   4                  }
  593   3              }
  594   2              if(return_state)
  595   2              {
  596   3                  break;
  597   3              }
  598   2              vl53l0x_write_register(VL53L0X_SYSTEM_INTERRUPT_CLEAR, 0x01);
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 11  

  599   2              vl53l0x_write_register(VL53L0X_SYSRANGE_START, 0x00);
  600   2          }while(0);
  601   1      
  602   1          return return_state;
  603   1      }
  604          
  605          //-------------------------------------------------------------------------------------------------------
             -------------
  606          // å‡½æ•°ç®€ä»‹     è®¾ç½®æµ‹é‡å®šæ—¶é¢„ç®— (ä»¥å¾®ç§’ä¸ºå•ä½)
  607          // å‚æ•°è¯´æ˜     budget_us       è®¾å®šçš„æµ‹é‡å…è®¸çš„æ—¶é—´
  608          // è¿”å›å‚æ•°     uint8           æ“ä½œç»“æœ 0-æˆåŠŸ 1-å¤±è´¥
  609          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_set_measurement_timing_budget(measurement_timing_budget_us);
  610          // å¤‡æ³¨ä¿¡æ¯     è¿™æ˜¯ä¸€æ¬¡æµ‹é‡å…è®¸çš„æ—¶é—´
  611          //              å³åœ¨æµ‹è·åºåˆ—çš„å­æ­¥éª¤ä¹‹é—´åˆ†é…æ—¶é—´é¢„ç®—
  612          //              æ›´é•¿çš„æ—¶é—´é¢„ç®—å…è®¸æ›´ç²¾ç¡®çš„æµ‹é‡
  613          //              å¢åŠ ä¸€ä¸ªNå€çš„é¢„ç®—å¯ä»¥å‡å°‘ä¸€ä¸ªsqrt(N)å€çš„èŒƒå›´æµ‹é‡æ ‡å‡†åå·®
  614          //              é»˜è®¤ä¸º33æ¯«ç§’ æœ€å°å€¼ä¸º20 ms
  615          //-------------------------------------------------------------------------------------------------------
             -------------
  616          static uint8 vl53l0x_set_measurement_timing_budget (uint32 budget_us)
  617          {
  618   1          uint8 return_state = 0;
  619   1          uint8 data_buffer[3];
  620   1          uint16 dat = 0;
  621   1        uint32 used_budget_us;
  622   1        uint32 final_range_timeout_us;
  623   1        uint16 final_range_timeout_mclks;
  624   1        
  625   1          vl53l0x_sequence_enables_step_struct enables;
  626   1          vl53l0x_sequence_timeout_step_struct timeouts;
  627   1      
  628   1          do
  629   1          {
  630   2              if (budget_us < VL53L0X_MIN_TIMING_BUDGET)
  631   2              {
  632   3                  return_state = 1;
  633   3                  break;
  634   3              }
  635   2      
  636   2              used_budget_us = VL53L0X_SET_START_OVERHEAD + VL53L0X_END_OVERHEAD;
  637   2              vl53l0x_get_sequence_step_enables(&enables);
  638   2              vl53l0x_get_sequence_step_timeouts(&enables, &timeouts);
  639   2      
  640   2              if (enables.tcc)
  641   2              {
  642   3                  used_budget_us += (timeouts.msrc_dss_tcc_us + VL53L0X_TCC_OVERHEAD);
  643   3              }
  644   2      
  645   2              if (enables.dss)
  646   2              {
  647   3                  used_budget_us += 2 * (timeouts.msrc_dss_tcc_us + VL53L0X_DSS_OVERHEAD);
  648   3              }
  649   2              else if (enables.msrc)
  650   2              {
  651   3                  used_budget_us += (timeouts.msrc_dss_tcc_us + VL53L0X_MSRC_OVERHEAD);
  652   3              }
  653   2      
  654   2              if (enables.pre_range)
  655   2              {
  656   3                  used_budget_us += (timeouts.pre_range_us + VL53L0X_PRERANGE_OVERHEAD);
  657   3              }
  658   2      
  659   2              if (enables.final_range)
  660   2              {
  661   3                  // è¯·æ³¨æ„ æœ€ç»ˆèŒƒå›´è¶…æ—¶ç”±è®¡æ—¶é¢„ç®—å’Œåºåˆ—ä¸­æ‰€æœ‰å…¶ä»–è¶…æ—¶çš„æ€»å’Œå†³å®š
  662   3                  // å¦‚æœæ²¡æœ‰ç©ºé—´ç”¨äºæœ€ç»ˆèŒƒå›´è¶…æ—¶ åˆ™å°†è®¾ç½®é”™è¯¯
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 12  

  663   3                  // å¦åˆ™ å‰©ä½™æ—¶é—´å°†åº”ç”¨äºæœ€ç»ˆèŒƒå›´
  664   3                  used_budget_us += VL53L0X_FINALlRANGE_OVERHEAD;
  665   3                  if (used_budget_us > budget_us)
  666   3                  {
  667   4                      // è¯·æ±‚çš„è¶…æ—¶å¤ªå¤§
  668   4                      return_state = 1;
  669   4                      break;
  670   4                  }
  671   3      
  672   3                  // å¯¹äºæœ€ç»ˆè¶…æ—¶èŒƒå›´ å¿…é¡»æ·»åŠ é¢„é‡ç¨‹èŒƒå›´è¶…æ—¶
  673   3                  // ä¸ºæ­¤ æœ€ç»ˆè¶…æ—¶å’Œé¢„é‡ç¨‹è¶…æ—¶å¿…é¡»ä»¥å®å‘¨æœŸ MClks è¡¨ç¤º
  674   3                  // å› ä¸ºå®ƒä»¬å…·æœ‰ä¸åŒçš„ VCSEL å‘¨æœŸ
  675   3                  final_range_timeout_us = budget_us - used_budget_us;
  676   3                  final_range_timeout_mclks =
  677   3                  vl53l0x_timeout_microseconds_to_mclks(final_range_timeout_us,
  678   3                           (uint8)timeouts.final_range_vcsel_period_pclks);
  679   3      
  680   3                  if (enables.pre_range)
  681   3                  {
  682   4                      final_range_timeout_mclks += timeouts.pre_range_mclks;
  683   4                  }
  684   3      
  685   3                  dat = vl53l0x_encode_timeout(final_range_timeout_mclks);
  686   3                  data_buffer[0] = VL53L0X_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI;
  687   3                  data_buffer[1] = ((dat >> 8) & 0xFF);
  688   3                  data_buffer[2] = (dat & 0xFF);
  689   3                  vl53l0x_write_array(data_buffer, 3);
  690   3              }
  691   2          }while(0);
  692   1          return return_state;
  693   1      }
  694          
  695          //-------------------------------------------------------------------------------------------------------
             -------------
  696          // å‡½æ•°ç®€ä»‹     è·å–æµ‹é‡å®šæ—¶é¢„ç®— (ä»¥å¾®ç§’ä¸ºå•ä½)
  697          // å‚æ•°è¯´æ˜     void
  698          // è¿”å›å‚æ•°     uint32          å·²è®¾å®šçš„æµ‹é‡å…è®¸çš„æ—¶é—´
  699          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_get_measurement_timing_budget();
  700          // å¤‡æ³¨ä¿¡æ¯     
  701          //-------------------------------------------------------------------------------------------------------
             -------------
  702          static uint32 vl53l0x_get_measurement_timing_budget (void)
  703          {
  704   1          vl53l0x_sequence_enables_step_struct enables;
  705   1          vl53l0x_sequence_timeout_step_struct timeouts;
  706   1      
  707   1          // å¼€å§‹å’Œç»“æŸå¼€é”€æ—¶é—´å§‹ç»ˆå­˜åœ¨
  708   1          uint32 budget_us = VL53L0X_GET_START_OVERHEAD + VL53L0X_END_OVERHEAD;
  709   1      
  710   1          vl53l0x_get_sequence_step_enables(&enables);
  711   1          vl53l0x_get_sequence_step_timeouts(&enables, &timeouts);
  712   1      
  713   1          if (enables.tcc)
  714   1          {
  715   2              budget_us += (timeouts.msrc_dss_tcc_us + VL53L0X_TCC_OVERHEAD);
  716   2          }
  717   1      
  718   1          if (enables.dss)
  719   1          {
  720   2              budget_us += 2 * (timeouts.msrc_dss_tcc_us + VL53L0X_DSS_OVERHEAD);
  721   2          }
  722   1          else if (enables.msrc)
  723   1          {
  724   2              budget_us += (timeouts.msrc_dss_tcc_us + VL53L0X_MSRC_OVERHEAD);
  725   2          }
  726   1      
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 13  

  727   1          if (enables.pre_range)
  728   1          {
  729   2              budget_us += (timeouts.pre_range_us + VL53L0X_PRERANGE_OVERHEAD);
  730   2          }
  731   1      
  732   1          if (enables.final_range)
  733   1          {
  734   2              budget_us += (timeouts.final_range_us + VL53L0X_FINALlRANGE_OVERHEAD);
  735   2          }
  736   1      
  737   1          return budget_us;
  738   1      }
  739          
  740          //-------------------------------------------------------------------------------------------------------
             -------------
  741          // å‡½æ•°ç®€ä»‹     è®¾ç½®è¿”å›ä¿¡å·é€Ÿç‡é™åˆ¶ è¯¥å€¼å•ä½ä¸º MCPS (ç™¾ä¸‡æ¬¡æ¯ç§’)
  742          // å‚æ•°è¯´æ˜     limit_mcps      è®¾ç½®çš„æœ€å°é€Ÿç‡
  743          // è¿”å›å‚æ•°     void
  744          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_set_signal_rate_limit(0.25);
  745          // å¤‡æ³¨ä¿¡æ¯     è¿™ä¸ªé€Ÿç‡è¡¨ç¤ºä»ç›®æ ‡åå°„å¹¶è¢«è®¾å¤‡æ£€æµ‹åˆ°çš„ä¿¡å·çš„æŒ¯å¹…
  746          //              è®¾ç½®æ­¤é™åˆ¶å¯ä»¥ç¡®å®šä¼ æ„Ÿå™¨æŠ¥å‘Šæœ‰æ•ˆè¯»æ•°æ‰€éœ€çš„æœ€å°æµ‹é‡å€¼
  747          //              è®¾ç½®ä¸€ä¸ªè¾ƒä½çš„é™åˆ¶å¯ä»¥å¢åŠ ä¼ æ„Ÿå™¨çš„æµ‹é‡èŒƒå›´
  748          //              ä½†ä¼¼ä¹ä¹Ÿå¢åŠ äº† <ç”±äºæ¥è‡ªç›®æ ‡ä»¥å¤–çš„ç‰©ä½“çš„ä¸éœ€è¦çš„åå°„å¯¼è‡´> å¾—å
             -ˆ°ä¸å‡†ç¡®è¯»æ•°çš„å¯èƒ½æ€§
  749          //              é»˜è®¤ä¸º 0.25 MCPS å¯é¢„è®¾èŒƒå›´ä¸º 0 - 511.99
  750          //-------------------------------------------------------------------------------------------------------
             -------------
  751          static void vl53l0x_set_signal_rate_limit (float limit_mcps)
  752          {
  753   1        uint8 data_buffer[3];
  754   1          uint16 limit_mcps_16bit = (limit_mcps * (1 << 7));
  755   1          //zf_assert(limit_mcps >= 0 || limit_mcps <= 511.99);
  756   1      
  757   1      
  758   1          data_buffer[0] = VL53L0X_FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT;
  759   1          data_buffer[1] = ((limit_mcps_16bit >> 8) & 0xFF);
  760   1          data_buffer[2] = (limit_mcps_16bit & 0xFF);
  761   1      
  762   1          vl53l0x_write_array(data_buffer, 3);
  763   1      }
  764          
  765          //-------------------------------------------------------------------------------------------------------
             -------------
  766          // å‡½æ•°ç®€ä»‹     è¿”å›ä»¥æ¯«ç±³ä¸ºå•ä½çš„èŒƒå›´è¯»æ•°
  767          // å‚æ•°è¯´æ˜     void
  768          // è¿”å›å‚æ•°     uint8           0-æ•°æ®æ— æ•ˆ 1-æ•°æ®æœ‰æ•ˆ
  769          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_get_distance();
  770          // å¤‡æ³¨ä¿¡æ¯     åœ¨å¼€å§‹å•æ¬¡å°„ç¨‹æµ‹é‡åä¹Ÿè°ƒç”¨æ­¤å‡½æ•°
  771          //-------------------------------------------------------------------------------------------------------
             -------------
  772          void vl53l0x_get_distance (void)
  773          {
  774   1          uint8 reg_databuffer[3];
  775   1      
  776   1          vl53l0x_read_registers_1(VL53L0X_RESULT_INTERRUPT_STATUS, reg_databuffer, 1);
  777   1          if((reg_databuffer[0] & 0x07) == 0)
  778   1          {
  779   2              vl53l0x_finsh_flag = 0;
  780   2          }
  781   1          else
  782   1          {
  783   2              // å‡è®¾çº¿æ€§åº¦æ ¡æ­£å¢ç›Šä¸ºé»˜è®¤å€¼ 1000 ä¸”æœªå¯ç”¨åˆ†æ•°èŒƒå›´
  784   2              vl53l0x_read_registers_1(VL53L0X_RESULT_RANGE_STATUS + 10, reg_databuffer, 2);
  785   2              vl53l0x_distance_mm = ((uint16)reg_databuffer[0] << 8);
  786   2              vl53l0x_distance_mm |= reg_databuffer[1];
  787   2      
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 14  

  788   2              vl53l0x_write_register(VL53L0X_SYSTEM_INTERRUPT_CLEAR, 0x01);
  789   2              vl53l0x_finsh_flag = 1;
  790   2          }
  791   1      }
  792          
  793          //-------------------------------------------------------------------------------------------------------
             -------------
  794          // å‡½æ•°ç®€ä»‹     åˆå§‹åŒ– VL53L0X
  795          // å‚æ•°è¯´æ˜     void
  796          // è¿”å›å‚æ•°     uint8           1-åˆå§‹åŒ–å¤±è´¥ 0-åˆå§‹åŒ–æˆåŠŸ
  797          // ä½¿ç”¨ç¤ºä¾‹     vl53l0x_init();
  798          // å¤‡æ³¨ä¿¡æ¯     
  799          //-------------------------------------------------------------------------------------------------------
             -------------
  800          uint8 vl53l0x_init (void)
  801          {
  802   1          uint32 measurement_timing_budget_us = 0;
  803   1          uint8 stop_variable = 0;
  804   1          uint8 return_state = 0;
  805   1          uint8 reg_data_buffer = 0;
  806   1          uint8 ref_spad_map[6];
  807   1          uint8 data_buffer[7];
  808   1        uint8 i = 0;
  809   1        
  810   1          memset(ref_spad_map, 0, 6);
  811   1          memset(data_buffer, 0, 7);
  812   1      
  813   1      
  814   1      
  815   1          do
  816   1          {
  817   2              delay_ms(100);
  818   2              VL53L0X_XSHUT_PIN = 0;
  819   2              delay_ms(50);
  820   2              VL53L0X_XSHUT_PIN = 1;
  821   2              delay_ms(100);
  822   2      
  823   2              // -------------------------------- VL53L0X å¯åŠ¨åˆå§‹åŒ– --------------------------------
  824   2              reg_data_buffer = vl53l0x_read_register(VL53L0X_IO_VOLTAGE_CONFIG);         // ä¼ æ„Ÿå™¨é»˜è®¤ IO
             - ä¸º 1.8V æ¨¡å¼
  825   2              vl53l0x_write_register(VL53L0X_IO_VOLTAGE_CONFIG, reg_data_buffer | 0x01);  // é…ç½® IO ä¸º 2.8V
             - æ¨¡å¼
  826   2      
  827   2              vl53l0x_write_register(0x88, 0x00);                                         // è®¾ç½®ä¸ºæ ‡å‡† II
             -C æ¨¡å¼
  828   2      
  829   2              vl53l0x_write_register(0x80, 0x01);
  830   2              vl53l0x_write_register(0xFF, 0x01);
  831   2              vl53l0x_write_register(0x00, 0x00);
  832   2      
  833   2              vl53l0x_read_registers(0x91, &stop_variable , 1);
  834   2      
  835   2              vl53l0x_write_register(0x00, 0x01);
  836   2              vl53l0x_write_register(0xFF, 0x00);
  837   2              vl53l0x_write_register(0x80, 0x00);
  838   2      
  839   2              // ç¦ç”¨ SIGNAL_RATE_MSRC(bit1) å’Œ SIGNAL_RATE_PRE_RANGE(bit4) é™åˆ¶æ£€æŸ¥
  840   2              reg_data_buffer = vl53l0x_read_register(VL53L0X_MSRC_CONFIG);
  841   2              vl53l0x_write_register(VL53L0X_MSRC_CONFIG, reg_data_buffer | 0x12);
  842   2      
  843   2              vl53l0x_set_signal_rate_limit(VL53L0X_DEFAULT_RATE_LIMIT);                  // è®¾ç½®ä¿¡å·é€Ÿç‡
             -é™åˆ¶
  844   2              vl53l0x_write_register(VL53L0X_SYSTEM_SEQUENCE_CONFIG, 0xFF);
  845   2              // -------------------------------- VL53L0X å¯åŠ¨åˆå§‹åŒ– --------------------------------
  846   2      
  847   2              // -------------------------------- VL53L0X é…ç½®åˆå§‹åŒ– --------------------------------
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 15  

  848   2              if (vl53l0x_get_spad_info(&data_buffer[0], &data_buffer[1]))
  849   2              {
  850   3            return_state = 1;
  851   3                  // å¦‚æœç¨‹åºåœ¨è¾“å‡ºäº†æ–­è¨€ä¿¡æ¯ å¹¶ä¸”æç¤ºå‡ºé”™ä½ç½®åœ¨è¿™é‡Œ
  852   3                  // é‚£ä¹ˆå°±æ˜¯ vl53l0x è‡ªæ£€å‡ºé”™å¹¶è¶…æ—¶é€€å‡ºäº†
  853   3                  // æ£€æŸ¥ä¸€ä¸‹æ¥çº¿æœ‰æ²¡æœ‰é—®é¢˜ å¦‚æœæ²¡é—®é¢˜å¯èƒ½å°±æ˜¯åäº†
  854   3      
  855   3            printf("vl53l0x init error.\r\n");
  856   3            break;
  857   3              }
  858   2      
  859   2              // ä» GLOBAL_CONFIG_SPAD_ENABLES_REF_[0-6] è·å– SPAD map (RefGoodSpadMap) æ•°æ®
  860   2              vl53l0x_read_registers(VL53L0X_GLOBAL_CONFIG_SPAD_ENABLES_REF_0, ref_spad_map, 6);
  861   2      
  862   2              vl53l0x_write_register(0xFF, 0x01);
  863   2              vl53l0x_write_register(VL53L0X_DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);
  864   2              vl53l0x_write_register(VL53L0X_DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
  865   2              vl53l0x_write_register(0xFF, 0x00);
  866   2              vl53l0x_write_register(VL53L0X_GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);
  867   2      
  868   2              data_buffer[2] = data_buffer[1] ? 12 : 0; // 12 is the first aperture spad
  869   2              for (i = 0; i < 48; i++)
  870   2              {
  871   3                  if (i < data_buffer[2] || data_buffer[3] == data_buffer[0])
  872   3                  {
  873   4                      // æ­¤ä½ä½äºåº”å¯ç”¨çš„ç¬¬ä¸€ä¸ªä½
  874   4                      // æˆ–è€… (eference_spad_count) ä½å·²å¯ç”¨
  875   4                      // å› æ­¤æ­¤ä½ä¸ºé›¶
  876   4                      ref_spad_map[i / 8] &= ~(1 << (i % 8));
  877   4                  }
  878   3                  else if ((ref_spad_map[i / 8] >> (i % 8)) & 0x1)
  879   3                  {
  880   4                      data_buffer[3]++;
  881   4                  }
  882   3              }
  883   2      
  884   2              data_buffer[0] = VL53L0X_GLOBAL_CONFIG_SPAD_ENABLES_REF_0;
  885   2              for(i = 1; i < 7; i++)
  886   2              {
  887   3                  data_buffer[1] = ref_spad_map[i-1];
  888   3              }
  889   2              vl53l0x_write_array(data_buffer, 7);
  890   2      
  891   2              // é»˜è®¤è½¬æ¢è®¾ç½® version 02/11/2015_v36
  892   2              vl53l0x_write_register(0xFF, 0x01);
  893   2              vl53l0x_write_register(0x00, 0x00);
  894   2              vl53l0x_write_register(0xFF, 0x00);
  895   2              vl53l0x_write_register(0x09, 0x00);
  896   2              vl53l0x_write_register(0x10, 0x00);
  897   2              vl53l0x_write_register(0x11, 0x00);
  898   2              vl53l0x_write_register(0x24, 0x01);
  899   2              vl53l0x_write_register(0x25, 0xFF);
  900   2              vl53l0x_write_register(0x75, 0x00);
  901   2              vl53l0x_write_register(0xFF, 0x01);
  902   2              vl53l0x_write_register(0x4E, 0x2C);
  903   2              vl53l0x_write_register(0x48, 0x00);
  904   2              vl53l0x_write_register(0x30, 0x20);
  905   2              vl53l0x_write_register(0xFF, 0x00);
  906   2              vl53l0x_write_register(0x30, 0x09);
  907   2              vl53l0x_write_register(0x54, 0x00);
  908   2              vl53l0x_write_register(0x31, 0x04);
  909   2              vl53l0x_write_register(0x32, 0x03);
  910   2              vl53l0x_write_register(0x40, 0x83);
  911   2              vl53l0x_write_register(0x46, 0x25);
  912   2              vl53l0x_write_register(0x60, 0x00);
  913   2              vl53l0x_write_register(0x27, 0x00);
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 16  

  914   2              vl53l0x_write_register(0x50, 0x06);
  915   2              vl53l0x_write_register(0x51, 0x00);
  916   2              vl53l0x_write_register(0x52, 0x96);
  917   2              vl53l0x_write_register(0x56, 0x08);
  918   2              vl53l0x_write_register(0x57, 0x30);
  919   2              vl53l0x_write_register(0x61, 0x00);
  920   2              vl53l0x_write_register(0x62, 0x00);
  921   2              vl53l0x_write_register(0x64, 0x00);
  922   2              vl53l0x_write_register(0x65, 0x00);
  923   2              vl53l0x_write_register(0x66, 0xA0);
  924   2              vl53l0x_write_register(0xFF, 0x01);
  925   2              vl53l0x_write_register(0x22, 0x32);
  926   2              vl53l0x_write_register(0x47, 0x14);
  927   2              vl53l0x_write_register(0x49, 0xFF);
  928   2              vl53l0x_write_register(0x4A, 0x00);
  929   2              vl53l0x_write_register(0xFF, 0x00);
  930   2              vl53l0x_write_register(0x7A, 0x0A);
  931   2              vl53l0x_write_register(0x7B, 0x00);
  932   2              vl53l0x_write_register(0x78, 0x21);
  933   2              vl53l0x_write_register(0xFF, 0x01);
  934   2              vl53l0x_write_register(0x23, 0x34);
  935   2              vl53l0x_write_register(0x42, 0x00);
  936   2              vl53l0x_write_register(0x44, 0xFF);
  937   2              vl53l0x_write_register(0x45, 0x26);
  938   2              vl53l0x_write_register(0x46, 0x05);
  939   2              vl53l0x_write_register(0x40, 0x40);
  940   2              vl53l0x_write_register(0x0E, 0x06);
  941   2              vl53l0x_write_register(0x20, 0x1A);
  942   2              vl53l0x_write_register(0x43, 0x40);
  943   2              vl53l0x_write_register(0xFF, 0x00);
  944   2              vl53l0x_write_register(0x34, 0x03);
  945   2              vl53l0x_write_register(0x35, 0x44);
  946   2              vl53l0x_write_register(0xFF, 0x01);
  947   2              vl53l0x_write_register(0x31, 0x04);
  948   2              vl53l0x_write_register(0x4B, 0x09);
  949   2              vl53l0x_write_register(0x4C, 0x05);
  950   2              vl53l0x_write_register(0x4D, 0x04);
  951   2              vl53l0x_write_register(0xFF, 0x00);
  952   2              vl53l0x_write_register(0x44, 0x00);
  953   2              vl53l0x_write_register(0x45, 0x20);
  954   2              vl53l0x_write_register(0x47, 0x08);
  955   2              vl53l0x_write_register(0x48, 0x28);
  956   2              vl53l0x_write_register(0x67, 0x00);
  957   2              vl53l0x_write_register(0x70, 0x04);
  958   2              vl53l0x_write_register(0x71, 0x01);
  959   2              vl53l0x_write_register(0x72, 0xFE);
  960   2              vl53l0x_write_register(0x76, 0x00);
  961   2              vl53l0x_write_register(0x77, 0x00);
  962   2              vl53l0x_write_register(0xFF, 0x01);
  963   2              vl53l0x_write_register(0x0D, 0x01);
  964   2              vl53l0x_write_register(0xFF, 0x00);
  965   2              vl53l0x_write_register(0x80, 0x01);
  966   2              vl53l0x_write_register(0x01, 0xF8);
  967   2              vl53l0x_write_register(0xFF, 0x01);
  968   2              vl53l0x_write_register(0x8E, 0x01);
  969   2              vl53l0x_write_register(0x00, 0x01);
  970   2              vl53l0x_write_register(0xFF, 0x00);
  971   2              vl53l0x_write_register(0x80, 0x00);
  972   2      
  973   2              // å°†ä¸­æ–­é…ç½®è®¾ç½®ä¸ºæ–°æ ·å“å°±ç»ª
  974   2              vl53l0x_write_register(VL53L0X_SYSTEM_INTERRUPT_GPIO_CONFIG, 0x04);
  975   2              reg_data_buffer = vl53l0x_read_register(VL53L0X_GPIO_HV_MUX_ACTIVE_HIGH);
  976   2              vl53l0x_write_register(VL53L0X_GPIO_HV_MUX_ACTIVE_HIGH, reg_data_buffer & ~0x10);
  977   2              vl53l0x_write_register(VL53L0X_SYSTEM_INTERRUPT_CLEAR, 0x01);
  978   2      
  979   2              measurement_timing_budget_us  = vl53l0x_get_measurement_timing_budget();
C251 COMPILER V5.60.0,  SEEKFREE_VL53L0X                                                   15/06/23  10:54:24  PAGE 17  

  980   2      
  981   2              // é»˜è®¤æƒ…å†µä¸‹ç¦ç”¨ MSRC å’Œ TCC
  982   2              // MSRC = Minimum Signal Rate Check
  983   2              // TCC = Target CentreCheck
  984   2              vl53l0x_write_register(VL53L0X_SYSTEM_SEQUENCE_CONFIG, 0xE8);
  985   2              vl53l0x_set_measurement_timing_budget(measurement_timing_budget_us);    // é‡æ–°è®¡ç®—æ—¶åºé¢„ç
             -®—
  986   2              // -------------------------------- VL53L0X é…ç½®åˆå§‹åŒ– --------------------------------
  987   2      
  988   2              vl53l0x_write_register(VL53L0X_SYSTEM_SEQUENCE_CONFIG, 0x01);
  989   2              if (vl53l0x_perform_single_ref_calibration(0x40))
  990   2              {
  991   3                  return_state = 1;
  992   3                  break;
  993   3              }
  994   2              vl53l0x_write_register(VL53L0X_SYSTEM_SEQUENCE_CONFIG, 0x02);
  995   2              if (vl53l0x_perform_single_ref_calibration(0x00))
  996   2              {
  997   3                  return_state = 1;
  998   3                  break;
  999   3              }
 1000   2              vl53l0x_write_register(VL53L0X_SYSTEM_SEQUENCE_CONFIG, 0xE8);           // æ¢å¤ä»¥å‰çš„åºåˆ—é
             -…ç½®
 1001   2      
 1002   2              delay_ms(100);
 1003   2      
 1004   2              vl53l0x_write_register(0x80, 0x01);
 1005   2              vl53l0x_write_register(0xFF, 0x01);
 1006   2              vl53l0x_write_register(0x00, 0x00);
 1007   2              vl53l0x_write_register(0x91, stop_variable);
 1008   2              vl53l0x_write_register(0x00, 0x01);
 1009   2              vl53l0x_write_register(0xFF, 0x00);
 1010   2              vl53l0x_write_register(0x80, 0x00);
 1011   2      
 1012   2              vl53l0x_write_register(VL53L0X_SYSRANGE_START, 0x02);
 1013   2          }while(0);
 1014   1      
 1015   1          return return_state;
 1016   1      }
 1017          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3617     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =         3        122
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        22     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
